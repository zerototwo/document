---
description: >-
  在分布式系统中，锁的设计必须考虑 互斥性、高可用性、可重入性、超时释放、容错性。下面对 数据库锁、Redis 锁、ZooKeeper 锁
  进行详细设计，适用于不同的业务场景。
---

# 如何设计高可用的分布式锁？

## 1. 数据库分布式锁

### 实现方式

#### 1. 基于数据库 INSERT 操作

```
INSERT INTO distributed_locks (lock_key, owner, expires_at)
VALUES ('resource_lock', 'node_1', NOW() + INTERVAL 10 SECOND);
```

• 利用唯一索引（lock\_key 为主键），保证只有一个节点成功 INSERT。

• 如果 INSERT 失败，则表示锁已被占用。

#### 2. 基于 SELECT ... FOR UPDATE

```
SELECT * FROM distributed_locks WHERE lock_key = 'resource_lock' FOR UPDATE;
```

• 加行锁，保证同一时间只有一个进程可以获取锁。

• 适用于单库高并发场景，但不适用于分布式数据库。

#### 3. 释放锁

```
DELETE FROM distributed_locks WHERE lock_key = 'resource_lock' AND owner = 'node_1';
```

• 删除锁时，确保 owner 一致，防止误删。

⚠️ 存在问题

| 问题            | 解决方案                   |
| ------------- | ---------------------- |
| 锁不能自动释放（进程崩溃） | 加过期时间（expires\_at）定期清理 |
| 性能问题（数据库锁竞争大） | 适用于低并发场景，不适合高吞吐系统      |
| 无可重入性         | 需要记录线程 ID，增加可重入机制      |

&#x20;适用场景：低并发业务（如配置中心）。

## &#x20;2. Redis 分布式锁

### 实现方式

#### 1. 使用 SET NX PX（原子操作）

```sh
SET resource_lock node_1 NX PX 10000  # 10s 过期时间
```

• NX（Not Exist） 确保只有一个客户端成功获取锁。

• PX（Expire） 防止死锁（进程崩溃后自动释放）。

#### 2. 释放锁（Lua 脚本保证原子性）

```sh
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end
```

• 防止误删：只有持有锁的节点才能删除锁。

#### 3. 续约机制（防止锁过期）

```sh
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("PEXPIRE", KEYS[1], 10000)
else
    return 0
end
```

• 适用于长时间任务，防止锁过期导致多个进程同时执行。

⚠️ 存在问题

| 问题              | 解决方案                     |
| --------------- | ------------------------ |
| Redis 主从同步导致锁丢失 | RedLock 算法，使用多个 Redis 实例 |
| 不可重入            | 使用 HSET 记录线程 ID + 计数     |
| 锁续约失败           | 定时心跳续约，防止锁意外释放           |

📌 适用场景：高并发（如秒杀、限流）。

## 3. RedLock 高可用分布式锁

RedLock 机制

1\. 多个 Redis 实例（通常 5 个）。

2\. 并行尝试获取锁，如果在 N/2 + 1 个节点成功，则锁成功。

3\. 超时释放，减少锁丢失风险。

⚠️ 存在问题

| 问题            | 解决方案                |
| ------------- | ------------------- |
| 增加 Redis 维护成本 | 适用于高一致性需求（如金融支付）    |
| 性能开销大         | 避免锁频繁加解锁，适用于长时间持有的锁 |

📌 适用场景：金融系统、高一致性业务（如 跨机房事务）。

## 4. ZooKeeper 分布式锁

### 实现方式

#### 1. 创建临时有序节点

```sh
create -e /locks/resource_lock
```

• 客户端 A 创建 /locks/resource\_lock\_00001

• 客户端 B 创建 /locks/resource\_lock\_00002

#### 2. 获取最小节点

• /locks/resource\_lock\_00001 获取锁。

• /locks/resource\_lock\_00002 监听 /locks/resource\_lock\_00001。

#### 3. 释放锁

• 自动删除（进程断开后 ZooKeeper 自动释放锁）。

• 主动删除（业务完成后删除锁）。

⚠️ 存在问题

| 问题           | 解决方案                 |
| ------------ | -------------------- |
| ZooKeeper 故障 | 采用3\~5 个 ZK 节点，保证可用性 |
| 吞吐量低         | 适用于事务性锁，不适用于高并发      |

📌 适用场景：事务协调、分布式数据库锁。

## &#x20;5. 设计高可用分布式锁的关键点

| 关键点  | Redis 分布式锁      | ZooKeeper 分布式锁 | 数据库分布式锁     |
| ---- | --------------- | -------------- | ----------- |
| 互斥性  | ✅ SET NX 确保唯一   | ✅ 依赖 ZK 节点有序性  | ✅ 数据库唯一索引   |
| 高可用性 | ❌ 单机 Redis 可能丢失 | ✅ ZK 主从同步机制    | ❌ 依赖数据库     |
| 可重入性 | ❌ 需额外存储线程 ID    | ✅ 天然支持         | ❌ 需额外逻辑     |
| 超时释放 | ✅ 通过 PX 设定超时    | ✅ 断开连接后自动释放    | ❌ 需定期清理     |
| 容错性  | ❌ 主从切换可能导致丢失    | ✅ ZK 具备高可用     | ❌ 数据库崩溃后锁丢失 |
| 性能   | ✅ 高             | ❌ 低            | ❌ 低         |

## 6. 选型建议

1\. 低并发场景 → 数据库锁，适合小型应用，如定时任务调度。

2\. 高并发场景 → Redis 锁，适用于秒杀、限流、缓存更新。

3\. 高一致性场景 → RedLock，适用于金融交易、分布式事务。

4\. 事务协调场景 → ZooKeeper 锁，适用于分布式数据库、任务调度。

## &#x20;7. 结论

* Redis 分布式锁 适合高并发，需处理主从同步问题。
* RedLock 提供高可用性，但成本较高，适用于强一致性。
* ZooKeeper 分布式锁 适用于事务、数据库分布式锁。
* 数据库锁 适用于低并发任务调度。
